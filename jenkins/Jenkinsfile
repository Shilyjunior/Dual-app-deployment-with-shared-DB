pipeline {
    agent {
        label 'Jenkins agent'
    }
    
    parameters {
        choice(name: 'APP_TYPE', choices: ['both', 'flask', 'node'], description: 'Select application to deploy')
        choice(name: 'VERSION_INCREMENT', choices: ['patch', 'minor', 'major'], description: 'Version increment type')
        booleanParam(name: 'DRY_RUN', defaultValue: false, description: 'Check mode (dry run) without making changes')
        booleanParam(name: 'SKIP_CLEANUP', defaultValue: false, description: 'Skip artifact cleanup (for debugging)')
    }
    
    environment {
        ANSIBLE_HOST_KEY_CHECKING = 'false'
        WORKSPACE_DIR = "/home/ubuntu/jenkins-workspace"
        AWS_DEFAULT_REGION = 'us-east-1'
        S3_BUCKET = 'group7-dual-app-artifacts'
        BUILD_TIMESTAMP = sh(script: "date +%Y%m%d_%H%M%S", returnStdout: true).trim()
        ARTIFACT_RETENTION_DAYS = '3'
        VERSION_FILE = 'version.json'
    }
    
    stages {
        stage('Verify Agent Environment') {
            steps {
                script {
                    echo "ðŸ” Checking agent environment..."
                    sh '''
                        echo "=== Running on: ==="
                        cat /etc/os-release
                        echo ""
                        echo "=== Ansible Version ==="
                        ansible --version || echo "Ansible not installed"
                        echo ""
                        echo "=== Python Version ==="
                        python3 --version || echo "Python3 not installed"
                        echo ""
                        echo "=== AWS CLI Version ==="
                        aws --version || echo "AWS CLI not installed"
                        echo ""
                        echo "=== jq Version (for JSON processing) ==="
                        jq --version || echo "jq not installed - installing..."
                        sudo apt-get update && sudo apt-get install -y jq || echo "Failed to install jq"
                        echo ""
                        echo "=== Current Directory ==="
                        pwd
                        ls -la
                        echo ""
                        echo "=== Disk Space ==="
                        df -h
                    '''
                }
            }
        }
        
        stage('Checkout and Explore Repository') {
            steps {
                script {
                    echo "ðŸ“¥ Checking out repository..."
                    checkout scm
                    
                    echo "ðŸ” Exploring repository structure..."
                    sh '''
                        echo "=== Repository Contents ==="
                        ls -la
                        echo ""
                        echo "=== Ansible directory ==="
                        ls -la ansible/ 2>/dev/null || echo "No ansible directory found"
                        echo ""
                        echo "=== Apps directory ==="
                        ls -la apps/ 2>/dev/null || echo "No apps directory found"
                    '''
                }
            }
        }
        
        stage('Version Management') {
            steps {
                script {
                    echo "ðŸ·ï¸ Managing application versions..."
                    
                    // Ensure bucket exists for version management
                    sh """
                        aws s3 mb s3://${env.S3_BUCKET} || echo "Bucket already exists or creation failed"
                    """
                    
                    // Download existing version file or create new one and calculate versions
                    sh '''
                        echo "Checking for existing version file..."
                        if aws s3 cp s3://${S3_BUCKET}/versions/${VERSION_FILE} . 2>/dev/null; then
                            echo "âœ… Found existing version file"
                            cat ${VERSION_FILE}
                        else
                            echo "ðŸ“ Creating initial version file"
                            cat > ${VERSION_FILE} << 'EOF'
{
  "flask": {
    "current": "1.0.0",
    "history": ["1.0.0"]
  },
  "node": {
    "current": "1.0.0", 
    "history": ["1.0.0"]
  }
}
EOF
                        fi
                        
                        echo "=== Calculating new versions ==="
                        
                        # Extract current Flask version
                        CURRENT_FLASK_VERSION=$(jq -r '.flask.current' ${VERSION_FILE})
                        echo "Current Flask version: $CURRENT_FLASK_VERSION"
                        
                        # Extract current Node version  
                        CURRENT_NODE_VERSION=$(jq -r '.node.current' ${VERSION_FILE})
                        echo "Current Node version: $CURRENT_NODE_VERSION"
                        
                        # Function to increment version
                        increment_version() {
                            local current_version=$1
                            local increment_type=$2
                            
                            # Split version into parts
                            IFS='.' read -r major minor patch <<< "$current_version"
                            
                            case $increment_type in
                                "major")
                                    major=$((major + 1))
                                    minor=0
                                    patch=0
                                    ;;
                                "minor")
                                    minor=$((minor + 1))
                                    patch=0
                                    ;;
                                "patch"|*)
                                    patch=$((patch + 1))
                                    ;;
                            esac
                            
                            echo "${major}.${minor}.${patch}"
                        }
                        
                        # Calculate new versions
                        NEW_FLASK_VERSION=$(increment_version $CURRENT_FLASK_VERSION ${VERSION_INCREMENT})
                        NEW_NODE_VERSION=$(increment_version $CURRENT_NODE_VERSION ${VERSION_INCREMENT})
                        
                        echo "New Flask version: $NEW_FLASK_VERSION"
                        echo "New Node version: $NEW_NODE_VERSION"
                        
                        # Export versions for later stages
                        echo "FLASK_VERSION=$NEW_FLASK_VERSION" > versions.env
                        echo "NODE_VERSION=$NEW_NODE_VERSION" >> versions.env
                        
                        cat versions.env
                    '''
                    
                    // Load calculated versions into environment
                    def versionProps = readFile('versions.env')
                    versionProps.split('\n').each { line ->
                        if (line.contains('=')) {
                            def (key, value) = line.split('=', 2)
                            env[key] = value
                        }
                    }
                    
                    echo "ðŸ“‹ Version Information:"
                    echo "Flask Version: ${env.FLASK_VERSION}"
                    echo "Node Version: ${env.NODE_VERSION}"
                    echo "Version Increment Type: ${params.VERSION_INCREMENT}"
                }
            }
        }
        
        stage('Validate Configuration') {
            steps {
                script {
                    echo "âœ… Validating configuration files..."
                    
                    sh '''
                        echo "=== Critical Files Check ==="
                        [ -f "ansible/deploy-apps.yml" ] && echo "âœ… Main playbook exists" || echo "âŒ Main playbook missing"
                        [ -f "ansible/inventory/host.ini" ] && echo "âœ… Inventory exists" || echo "âŒ Inventory missing"
                        [ -d "apps/flask-app" ] && echo "âœ… Flask app directory exists" || echo "âŒ Flask app directory missing"
                        [ -d "apps/node-app" ] && echo "âœ… Node.js app directory exists" || echo "âŒ Node.js app directory missing"
                        [ -f "db/init.sql" ] && echo "âœ… DB init exists" || echo "âŒ DB init missing"
                        
                        echo ""
                        echo "=== Inventory Content ==="
                        cat ansible/inventory/host.ini 2>/dev/null || echo "Inventory file not accessible"
                    '''
                }
            }
        }
        
        stage('Test AWS S3 Access') {
            steps {
                script {
                    echo "ðŸ” Testing AWS S3 access..."
                    sh '''
                        echo "=== Testing IAM Role Access ==="
                        aws sts get-caller-identity
                        
                        echo "=== Testing S3 Bucket Access ==="
                        if aws s3 ls s3://group7-dual-app-artifacts/; then
                            echo "âœ… S3 bucket access SUCCESS"
                        else
                            echo "âš ï¸  Bucket might not exist yet, will create during upload"
                        fi
                    '''
                }
            }
        }
        
        stage('Test Ansible Connectivity') {
            steps {
                script {
                    echo "ðŸ”Œ Testing Ansible connectivity to target server..."
                    
                    sh '''
                        cd ansible
                        echo "=== Testing Ansible Ping ==="
                        ansible -i inventory/host.ini all -m ping -vvv
                        
                        if [ $? -eq 0 ]; then
                            echo "âœ… Ansible connectivity SUCCESS"
                        else
                            echo "âŒ Ansible connectivity FAILED"
                            echo "=== Attempting manual SSH test ==="
                            TARGET_IP=$(grep -oE "([0-9]{1,3}\\.){3}[0-9]{1,3}" inventory/host.ini | head -1)
                            ssh-keyscan -H $TARGET_IP >> ~/.ssh/known_hosts
                            ssh -o ConnectTimeout=10 ubuntu@$TARGET_IP "echo 'SSH connection successful'"
                        fi
                    '''
                }
            }
        }
        
        stage('Build Versioned Artifacts') {
            steps {
                script {
                    echo "ðŸ—ï¸ Building versioned deployment artifacts..."
                    sh 'mkdir -p artifacts'
                    
                    if (params.APP_TYPE == 'flask' || params.APP_TYPE == 'both') {
                        sh """
                            echo "Building Flask app v${env.FLASK_VERSION}"
                            if [ -d "apps/flask-app" ]; then
                                # Add version info to artifact
                                echo '{"version":"${env.FLASK_VERSION}","build":"${env.BUILD_NUMBER}","timestamp":"${env.BUILD_TIMESTAMP}"}' > apps/flask-app/version.json
                                
                                # Create versioned artifact
                                tar -czf artifacts/flask-app-${env.FLASK_VERSION}.tar.gz -C apps/flask-app .
                                echo "âœ… Flask artifact v${env.FLASK_VERSION} created successfully"
                                
                                # Verify artifact
                                ls -lh artifacts/flask-app-${env.FLASK_VERSION}.tar.gz
                            else
                                echo "âŒ Flask app directory not found"
                                exit 1
                            fi
                        """
                    }
                    
                    if (params.APP_TYPE == 'node' || params.APP_TYPE == 'both') {
                        sh """
                            echo "Building Node.js app v${env.NODE_VERSION}"
                            if [ -d "apps/node-app" ]; then
                                # Add version info to artifact
                                echo '{"version":"${env.NODE_VERSION}","build":"${env.BUILD_NUMBER}","timestamp":"${env.BUILD_TIMESTAMP}"}' > apps/node-app/version.json
                                
                                # Create versioned artifact
                                tar -czf artifacts/node-app-${env.NODE_VERSION}.tar.gz -C apps/node-app .
                                echo "âœ… Node.js artifact v${env.NODE_VERSION} created successfully"
                                
                                # Verify artifact
                                ls -lh artifacts/node-app-${env.NODE_VERSION}.tar.gz
                            else
                                echo "âŒ Node.js app directory not found"
                                exit 1
                            fi
                        """
                    }
                    
                    sh '''
                        echo "=== Created Artifacts ==="
                        ls -la artifacts/ 2>/dev/null || echo "No artifacts directory"
                    '''
                }
            }
        }
        
        stage('Upload Versioned Artifacts to S3') {
            steps {
                script {
                    echo "ðŸ“¤ Uploading versioned artifacts to S3..."
                    
                    // Upload Flask artifact if exists
                    if (fileExists("artifacts/flask-app-${env.FLASK_VERSION}.tar.gz")) {
                        sh """
                            echo "Uploading Flask artifact v${env.FLASK_VERSION} to S3..."
                            aws s3 cp artifacts/flask-app-${env.FLASK_VERSION}.tar.gz \
                                s3://${env.S3_BUCKET}/artifacts/flask/${env.FLASK_VERSION}/flask-app-${env.FLASK_VERSION}.tar.gz \
                                --metadata version=${env.FLASK_VERSION},build=${env.BUILD_NUMBER},timestamp=${env.BUILD_TIMESTAMP},app=flask
                            echo "âœ… Flask artifact v${env.FLASK_VERSION} uploaded to S3"
                        """
                    }
                    
                    // Upload Node.js artifact if exists
                    if (fileExists("artifacts/node-app-${env.NODE_VERSION}.tar.gz")) {
                        sh """
                            echo "Uploading Node.js artifact v${env.NODE_VERSION} to S3..."
                            aws s3 cp artifacts/node-app-${env.NODE_VERSION}.tar.gz \
                                s3://${env.S3_BUCKET}/artifacts/node/${env.NODE_VERSION}/node-app-${env.NODE_VERSION}.tar.gz \
                                --metadata version=${env.NODE_VERSION},build=${env.BUILD_NUMBER},timestamp=${env.BUILD_TIMESTAMP},app=node
                            echo "âœ… Node.js artifact v${env.NODE_VERSION} uploaded to S3"
                        """
                    }
                    
                    // Update and upload version file
                    updateVersionFile()
                    
                    // List uploaded artifacts
                    sh """
                        echo "=== Current Flask Artifacts ==="
                        aws s3 ls s3://${env.S3_BUCKET}/artifacts/flask/ --recursive --human-readable || echo "No Flask artifacts"
                        echo ""
                        echo "=== Current Node.js Artifacts ==="
                        aws s3 ls s3://${env.S3_BUCKET}/artifacts/node/ --recursive --human-readable || echo "No Node.js artifacts"
                    """
                }
            }
        }
        
        stage('Cleanup Old Artifacts') {
            when {
                expression { !params.SKIP_CLEANUP }
            }
            steps {
                script {
                    echo "ðŸ§¹ Cleaning up artifacts older than ${env.ARTIFACT_RETENTION_DAYS} days..."
                    
                    sh """
                        # Calculate cutoff date (3 days ago)
                        CUTOFF_DATE=\$(date -d "${env.ARTIFACT_RETENTION_DAYS} days ago" '+%Y-%m-%d')
                        echo "Cleaning artifacts older than: \$CUTOFF_DATE"
                        
                        # Function to clean artifacts for an app type
                        cleanup_app_artifacts() {
                            local app_type=\$1
                            echo "=== Cleaning \$app_type artifacts ==="
                            
                            # List all artifacts with dates
                            aws s3api list-objects-v2 --bucket ${env.S3_BUCKET} --prefix "artifacts/\$app_type/" --query 'Contents[?LastModified<`'\$CUTOFF_DATE'`].[Key,LastModified,Size]' --output table
                            
                            # Get list of old artifacts
                            OLD_ARTIFACTS=\$(aws s3api list-objects-v2 --bucket ${env.S3_BUCKET} --prefix "artifacts/\$app_type/" --query 'Contents[?LastModified<`'\$CUTOFF_DATE'`].Key' --output text)
                            
                            if [ ! -z "\$OLD_ARTIFACTS" ] && [ "\$OLD_ARTIFACTS" != "None" ]; then
                                echo "Found old \$app_type artifacts to delete:"
                                echo "\$OLD_ARTIFACTS"
                                
                                # Delete old artifacts
                                for artifact in \$OLD_ARTIFACTS; do
                                    echo "Deleting: \$artifact"
                                    aws s3 rm s3://${env.S3_BUCKET}/\$artifact
                                done
                                echo "âœ… Old \$app_type artifacts cleaned up"
                            else
                                echo "â„¹ï¸  No old \$app_type artifacts to clean"
                            fi
                        }
                        
                        # Clean Flask artifacts
                        cleanup_app_artifacts "flask"
                        
                        # Clean Node.js artifacts
                        cleanup_app_artifacts "node"
                        
                        # Also clean old deployment reports
                        echo "=== Cleaning old deployment reports ==="
                        OLD_REPORTS=\$(aws s3api list-objects-v2 --bucket ${env.S3_BUCKET} --prefix "deployments/" --query 'Contents[?LastModified<`'\$CUTOFF_DATE'`].Key' --output text)
                        
                        if [ ! -z "\$OLD_REPORTS" ] && [ "\$OLD_REPORTS" != "None" ]; then
                            echo "Found old deployment reports to delete:"
                            echo "\$OLD_REPORTS"
                            for report in \$OLD_REPORTS; do
                                echo "Deleting: \$report"
                                aws s3 rm s3://${env.S3_BUCKET}/\$report
                            done
                            echo "âœ… Old deployment reports cleaned up"
                        else
                            echo "â„¹ï¸  No old deployment reports to clean"
                        fi
                        
                        echo "ðŸŽ¯ Cleanup completed!"
                    """
                }
            }
        }
        
        stage('Deploy Applications') {
            when {
                expression { 
                    !params.DRY_RUN && 
                    fileExists('ansible/deploy-apps.yml') &&
                    fileExists('ansible/inventory/host.ini')
                }
            }
            steps {
                script {
                    echo "ðŸš€ Deploying applications..."
                    
                    // Copy init.sql to temp location for Ansible
                    sh '''
                        mkdir -p /tmp/deployment
                        [ -f "db/init.sql" ] && cp db/init.sql /tmp/init.sql || echo "No init.sql found, using existing"
                    '''
                    
                    sh """
                        cd ansible
                        echo "=== Starting Ansible Deployment ==="
                        echo "Flask Version: ${env.FLASK_VERSION}"
                        echo "Node Version: ${env.NODE_VERSION}" 
                        echo "App Type: ${params.APP_TYPE}"
                        
                        ansible-playbook -i inventory/host.ini deploy-apps.yml \
                            --extra-vars "flask_version=${env.FLASK_VERSION} node_version=${env.NODE_VERSION} deployment_type=${params.APP_TYPE} s3_bucket=${env.S3_BUCKET}" \
                            --verbose
                    """
                }
            }
        }
        
        stage('Verify Deployment') {
            when {
                expression { !params.DRY_RUN }
            }
            steps {
                script {
                    echo "ðŸ” Verifying deployment..."
                    
                    // Extract target IP from inventory
                    def targetIP = sh(
                        script: 'cd ansible && grep -oE "([0-9]{1,3}\\.){3}[0-9]{1,3}" inventory/host.ini | head -1',
                        returnStdout: true
                    ).trim()
                    
                    echo "Target server IP: ${targetIP}"
                    
                    if (targetIP) {
                        // Test Flask app
                        if (params.APP_TYPE == 'flask' || params.APP_TYPE == 'both') {
                            sh """
                                echo "Testing Flask app v${env.FLASK_VERSION} on ${targetIP}:5000..."
                                for i in {1..5}; do
                                    if curl -f -s --connect-timeout 5 http://${targetIP}:5000 > /dev/null; then
                                        echo "âœ… Flask app v${env.FLASK_VERSION} is RUNNING"
                                        echo "Response preview:"
                                        curl -s http://${targetIP}:5000 | head -3
                                        
                                        # Check version endpoint if available
                                        curl -s http://${targetIP}:5000/version 2>/dev/null | jq . || echo "No version endpoint available"
                                        break
                                    else
                                        echo "â³ Attempt \$i: Flask app not ready..."
                                        sleep 5
                                    fi
                                done
                            """
                        }
                        
                        // Test Node.js app
                        if (params.APP_TYPE == 'node' || params.APP_TYPE == 'both') {
                            sh """
                                echo "Testing Node.js app v${env.NODE_VERSION} on ${targetIP}:3000..."
                                for i in {1..5}; do
                                    if curl -f -s --connect-timeout 5 http://${targetIP}:3000 > /dev/null; then
                                        echo "âœ… Node.js app v${env.NODE_VERSION} is RUNNING"
                                        echo "Response preview:"
                                        curl -s http://${targetIP}:3000 | head -3
                                        
                                        # Check version endpoint if available
                                        curl -s http://${targetIP}:3000/version 2>/dev/null | jq . || echo "No version endpoint available"
                                        break
                                    else
                                        echo "â³ Attempt \$i: Node.js app not ready..."
                                        sleep 5
                                    fi
                                done
                            """
                        }
                    } else {
                        echo "âŒ Could not determine target IP from inventory"
                    }
                }
            }
        }
    }
    
    post {
        always {
            echo "ðŸ Pipeline execution completed"
            script {
                // Create comprehensive deployment report
                sh """
                    echo "=== DEPLOYMENT REPORT ===" > report.txt
                    echo "Timestamp: \$(date)" >> report.txt
                    echo "Status: ${currentBuild.result ?: 'SUCCESS'}" >> report.txt
                    echo "Agent: \$(hostname)" >> report.txt
                    echo "Workspace: \$(pwd)" >> report.txt
                    echo "Applications: ${params.APP_TYPE}" >> report.txt
                    echo "Flask Version: ${env.FLASK_VERSION}" >> report.txt
                    echo "Node Version: ${env.NODE_VERSION}" >> report.txt
                    echo "Version Increment: ${params.VERSION_INCREMENT}" >> report.txt
                    echo "Build Number: ${env.BUILD_NUMBER}" >> report.txt
                    echo "Build Timestamp: ${env.BUILD_TIMESTAMP}" >> report.txt
                    echo "Artifact Retention: ${env.ARTIFACT_RETENTION_DAYS} days" >> report.txt
                    echo "" >> report.txt
                    echo "=== ARTIFACT LOCATIONS ===" >> report.txt
                    echo "Flask Artifacts: s3://${env.S3_BUCKET}/artifacts/flask/${env.FLASK_VERSION}/" >> report.txt
                    echo "Node Artifacts: s3://${env.S3_BUCKET}/artifacts/node/${env.NODE_VERSION}/" >> report.txt
                    echo "Version File: s3://${env.S3_BUCKET}/versions/${env.VERSION_FILE}" >> report.txt
                """
                
                // Upload report to S3
                def reportPath = "deployments/${env.JOB_NAME}/${env.BUILD_NUMBER}_${env.BUILD_TIMESTAMP}"
                sh """
                    aws s3 cp report.txt \
                        s3://${env.S3_BUCKET}/${reportPath}/deployment-report.txt \
                        --metadata build=${env.BUILD_NUMBER},timestamp=${env.BUILD_TIMESTAMP},flask_version=${env.FLASK_VERSION},node_version=${env.NODE_VERSION}
                """
                
                // Archive artifacts locally
                archiveArtifacts artifacts: 'artifacts/*.tar.gz, report.txt, version.json', fingerprint: true
                
                // Display summary
                echo "ðŸ“Š Deployment Summary:"
                echo "Flask Version: ${env.FLASK_VERSION}"
                echo "Node Version: ${env.NODE_VERSION}"
                echo "Report stored: s3://${env.S3_BUCKET}/${reportPath}/deployment-report.txt"
            }
        }
        
        success {
            echo "ðŸŽ‰ Deployment completed successfully!"
            script {
                def reportPath = "s3://${env.S3_BUCKET}/deployments/${env.JOB_NAME}/${env.BUILD_NUMBER}_${env.BUILD_TIMESTAMP}/"
                echo "âœ… Versioned artifacts successfully created and uploaded:"
                echo "   Flask v${env.FLASK_VERSION}: s3://${env.S3_BUCKET}/artifacts/flask/${env.FLASK_VERSION}/"
                echo "   Node v${env.NODE_VERSION}: s3://${env.S3_BUCKET}/artifacts/node/${env.NODE_VERSION}/"
                echo "ðŸ“Ž Deployment report: ${reportPath}deployment-report.txt"
                
                // Generate presigned URL for report (valid for 7 days)
                sh """
                    aws s3 presign s3://${env.S3_BUCKET}/deployments/${env.JOB_NAME}/${env.BUILD_NUMBER}_${env.BUILD_TIMESTAMP}/deployment-report.txt \
                        --expires-in 604800 > presigned-url.txt
                """
                def presignedUrl = readFile('presigned-url.txt').trim()
                echo "ðŸ”— Presigned report URL: ${presignedUrl}"
            }
        }
        
        failure {
            echo "âŒ Deployment failed!"
            script {
                sh '''
                    echo "=== TROUBLESHOOTING STEPS ==="
                    echo "1. Check agent connectivity: Is 'Jenkins agent' online?"
                    echo "2. Verify repository structure: Are all required files present?"
                    echo "3. Check version management: Review version.json file"
                    echo "4. Check Ansible installation on agent"
                    echo "5. Verify SSH connectivity to target server"
                    echo "6. Review Ansible playbook syntax and variables"
                    echo "7. Check AWS IAM role permissions for S3 access"
                    echo "8. Verify jq is installed for JSON processing"
                    echo ""
                    echo "=== CURRENT VERSIONS ==="
                    cat version.json 2>/dev/null || echo "No version file available"
                '''
            }
        }
        
        unstable {
            echo "âš ï¸ Deployment completed with warnings"
        }
    }
}

// Helper function to calculate new version
def calculateNewVersion(appType) {
    def versionFile = readFile('version.json')
    def versionData = readJSON text: versionFile
    
    def currentVersion = versionData[appType].current
    
    def versionParts = currentVersion.split('\\.')
    def major = Integer.parseInt(versionParts[0])
    def minor = Integer.parseInt(versionParts[1])
    def patch = Integer.parseInt(versionParts[2])
    
    switch(params.VERSION_INCREMENT) {
        case 'major':
            major++
            minor = 0
            patch = 0
            break
        case 'minor':
            minor++
            patch = 0
            break
        case 'patch':
        default:
            patch++
            break
    }
    
    return "${major}.${minor}.${patch}"
}

// Helper function to update version file
def updateVersionFile() {
    script {
        sh """
            # Update version file with new versions
            jq --arg flask_version "${env.FLASK_VERSION}" --arg node_version "${env.NODE_VERSION}" '
                .flask.current = \$flask_version |
                .flask.history += [\$flask_version] |
                .flask.history |= unique |
                .node.current = \$node_version |
                .node.history += [\$node_version] |
                .node.history |= unique
            ' ${env.VERSION_FILE} > ${env.VERSION_FILE}.tmp && mv ${env.VERSION_FILE}.tmp ${env.VERSION_FILE}
            
            echo "âœ… Updated version file:"
            cat ${env.VERSION_FILE}
            
            # Upload updated version file to S3
            aws s3 cp ${env.VERSION_FILE} s3://${env.S3_BUCKET}/versions/${env.VERSION_FILE} \
                --metadata build=${env.BUILD_NUMBER},timestamp=${env.BUILD_TIMESTAMP}
            
            echo "âœ… Version file uploaded to S3"
        """
    }
}